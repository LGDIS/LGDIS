<% if issue %>
<%= stylesheet_link_tag 'issue', :plugin => 'lgdis' %>

<table class="attributes">
<%= issue_fields_rows do |rows|
  if issue.xml_control_status
    rows.left l(:field_xml_control_status), h(issue.xml_control_status), :class => 'xml_control_status'
  end
  if issue.xml_control_editorialoffice
    rows.right l(:field_xml_control_editorialoffice), h(issue.xml_control_editorialoffice), :class => 'xml_control_editorialoffice'
  end
  if issue.xml_control_publishingoffice
    rows.left l(:field_xml_control_publishingoffice), h(issue.xml_control_publishingoffice), :class => 'xml_control_publishingoffice'
  end
  if issue.xml_control_cause
    rows.right l(:field_xml_control_cause), h(@issue_const['xml_control_cause'][issue.xml_control_cause]), :class => 'xml_control_cause'
  end
  if issue.xml_control_apply
    rows.left l(:field_xml_control_apply), h(@issue_const['xml_control_apply'][issue.xml_control_apply]), :class => 'xml_control_apply'
  end
  if issue.xml_head_title
    rows.right l(:field_xml_head_title), h(issue.xml_head_title), :class => 'xml_head_title'
  end
  if issue.xml_head_reportdatetime
    rows.left l(:field_xml_head_reportdatetime), format_time(issue.xml_head_reportdatetime), :class => 'xml_head_reportdatetime'
  end
  if issue.xml_head_targetdatetime
    rows.right l(:field_xml_head_targetdatetime), format_time(issue.xml_head_targetdatetime), :class => 'xml_head_targetdatetime'
  end
  if issue.xml_head_targetdtdubious
    rows.left l(:field_xml_head_targetdtdubious), h(issue.xml_head_targetdtdubious), :class => 'xml_head_targetdtdubious'
  end
  if issue.xml_head_targetduration
    rows.right l(:field_xml_head_targetduration), h(issue.xml_head_targetduration), :class => 'xml_head_targetduration'
  end
  if issue.xml_head_validdatetime
    rows.left l(:field_xml_head_validdatetime), format_time(issue.xml_head_validdatetime), :class => 'xml_head_validdatetime'
  end
  if issue.xml_head_eventid
    rows.right l(:field_xml_head_eventid), h(issue.xml_head_eventid), :class => 'xml_head_eventid'
  end
  if issue.xml_head_infotype
    rows.left l(:field_xml_head_infotype), h(issue.xml_head_infotype), :class => 'xml_head_infotype'
  end
  if issue.xml_head_serial
    rows.right l(:field_xml_head_serial), h(issue.xml_head_serial), :class => 'xml_head_serial'
  end
  if issue.xml_head_infokind
    rows.left l(:field_xml_head_infokind), h(issue.xml_head_infokind), :class => 'xml_head_infokind'
  end
  if issue.xml_head_infokindversion
    rows.right l(:field_xml_head_infokindversion), h(issue.xml_head_infokindversion), :class => 'xml_head_infokindversion'
  end
  if issue.xml_head_text
    rows.left l(:field_xml_head_text), h(issue.xml_head_text), :class => 'xml_head_text'
  end
end %>
</table>

<% if val = issue.xml_control %>
<hr />
<table class="attributes">
<tr>
  <th class="xml_control"><%= l(:field_xml_control) %>:</th>
</tr>
</table>
<%= print_xml_field(val, "xml_control") %>
<% end %>

<% if val = issue.xml_head %>
<hr />
<table class="attributes">
<tr>
  <th class="xml_head"><%= l(:field_xml_head) %>:</th>
</tr>
</table>
<%= print_xml_field(val, "xml_head") %>
<% end %>

<% if val = issue.xml_body %>
<hr />
<table class="attributes">
<tr>
  <th class="xml_body"><%= l(:field_xml_body) %>:</th>
</tr>
</table>
<%= print_xml_field(val, "xml_body") %>
<% end %>

<fieldset class="collapsible collapsed" >
<legend onclick="toggleFieldset(this); init();"><%= l(:map) %></legend>
    <div style="display: none;" id="map" class="map_field"></div>
</fieldset>

<% content_for :header_tags do %>
   <%= javascript_include_tag "//maps.google.com/maps/api/js?sensor=false&language=ja" %>
<% end %>

<script>
  //<![CDATA[
  // 地図表示
  // ------------------------------------------------
  // 地図表示用データ
  // DBから取得したデータを下記のような形式で記載してく
  // ------------------------------------------------
  // ポイントデータ作成
  // DBにポイントデータが複数存在する可能性があるため配列で全てのポイントデータを保持
  var global_points = <%== issue.points_for_map.to_json %>

  // ラインデータ作成
  // DBにラインデータが複数存在する可能性があるため配列で全てのラインデータを保持
  var global_lines = <%== issue.lines_for_map.to_json %>

  // ポリゴンデータ作成
  // DBにポリゴンデータが複数存在する可能性があるため配列で全てのポリゴンデータを作成
  var global_polygons = <%== issue.polygons_for_map.to_json %>

  // ロケーションデータ作成
  // DBにロケーションデータが複数存在する可能性があるため配列で全てのロケーションデータを作成
  var global_locations = <%== issue.locations_for_map.to_json %>
  // ------------------------------------------------
  // グローバル変数
  var map;
  // ------------------------------------------------
  // 各種メソッド

  // 初期化。bodyのonloadでinit()を指定することで呼び出してます
  function init() {
    // Google Mapで利用する初期設定用の変数
    var latlng = new google.maps.LatLng(<%= MAP_VALUES['ishi_lat'] %>,
                                        <%= MAP_VALUES['ishi_lon'] %>);
    var opts = {
      zoom: 12,
      mapTypeId: google.maps.MapTypeId.ROADMAP,
      center: latlng
    };

    // getElementById("map")の"map"は、body内の<div id="map">より
    map = new google.maps.Map(document.getElementById("map"), opts);

    // ポイントマーカー作成
    createPoints(global_points, map);

    // ポリライン作成
    createPolyline(global_lines, map);

    // ポリゴン作成
    createPolygon(global_polygons, map);

    // ロケーション作成
    createLocations(global_locations, map);
  }

  /**
   * ロケーションマーカー作成メソッド
   */
  function createLocations(locations, map) {
    var geocoder = new google.maps.Geocoder();  // Geocoding用インスタンス
    for (var i = 0; i < locations.length; i++) {
      // Location(地名)をGeocodingで座標データに変換する
      var location = locations[i].location;
      var remarks = locations[i].remarks;
      if (location) {
        geocoder.geocode({'address': location}, callback_geocode(remarks));
      }
    }
  }
  
  /**
   * geocode関数のコールバック処理
   */
  function callback_geocode(remarks) {
    return function(results, status) {
      if (status == google.maps.GeocoderStatus.OK) {
        // Goecoding成功の場合のみ処理
        var marker = new google.maps.Marker({
          position: results[0].geometry.location,
          map: map
        });
        
        if (remarks) {
          // マーカーオブジェクトに備考文字を設定
          // クリックイベント中にオブジェクトから文字列を取得する必要があるため
          marker.set('remarks', remarks);
          
          // クリックイベント時の処理
          google.maps.event.addListener(marker, 'click', function(e){
            var infowindow = new google.maps.InfoWindow({
                                 content: this.get('remarks'),
                                 position: e.latLng
                                 });
            // infoWindow表示
            infowindow.open(map);
          });
        }
      }
    }
  }
  
  /**
   * マーカー作成メソッド
   */
  function createPoints(points, map) {
    for (var i = 0; i < points.length; i++) {
      var point = points[i].points;
      var remarks = points[i].remarks;
      var marker = new google.maps.Marker({
          position: new google.maps.LatLng(point[0], point[1]),
          map: map

      });

      if (remarks) {
        // polylineオブジェクトに備考文字を設定
        // クリックイベント中にオブジェクトから文字列を取得する必要があるため
        marker.set('remarks', remarks);

        // クリックイベント時の処理
        google.maps.event.addListener(marker, 'click', function(e){
          var infowindow = new google.maps.InfoWindow({
                               content: this.get('remarks'), // thisはpolylineオブジェクト自体を指す
                               position: e.latLng
                                });
          // infoWindow表示
          infowindow.open(map);
        });
      }
    }
  }

  /**
   * ポリライン作成メソッド
   */
  function createPolyline(lines, map) {
    // 引数の配列数分ループ
    for (var i = 0; i < lines.length; i++) {
      var points = lines[i].points;
      var remarks = lines[i].remarks;

      // ポリラインオプション作成
      var pathArray = createPathArray(points) // points変数からpathの配列を作成
      var polylineOpts = {
          map: map,
          path: pathArray,
          strokeColor: "#666666",
          strokeOpacity: 0.9,
          strokeWeight: 2
      };

      // PolylineOptionsを利用してPolylineを作成
      var polyline = new google.maps.Polyline(polylineOpts);

      if (remarks) {
        // polylineオブジェクトに備考文字を設定
        // クリックイベント中にオブジェクトから文字列を取得する必要があるため
        polyline.set('remarks', remarks);
        // クリックイベント時の処理
        google.maps.event.addListener(polyline, 'click', function(e){
          var infowindow = new google.maps.InfoWindow({
                               content: this.get('remarks'), // thisはpolylineオブジェクト自体を指す
                               position: e.latLng
                                });
          // infoWindow表示
          infowindow.open(map);
        });
      }
    }
  }

  /**
   * ポリゴン作成メソッド
   */
  function createPolygon(polygons, map) {
    // 引数の配列数分ループ
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i].points;
      var remarks = polygons[i].remarks;
      // ポリラインオプション作成
      var pathArray = createPathArray(points) // points変数からpathの配列を作成
      var polygonOpts = {
          map: map,
          paths: pathArray,
          strokeColor: "#D96060",
          strokeOpacity: 1,
          strokeWeight: 1.5,
          fillColor: "#D96060",
          fillOpacity: 0.35
      };

      // polygonOptionsを利用してPolygonを作成
      var polygon = new google.maps.Polygon(polygonOpts);

      // remarks(備考)の値がある場合
      if (remarks) {
        // polygonオブジェクトに備考文字を設定
        // クリックイベント中にオブジェクトから文字列を取得する必要があるため
        polygon.set('remarks', remarks);

        // クリックイベント時の処理
        google.maps.event.addListener(polygon, 'click', function(e){
          var infowindow = new google.maps.InfoWindow({
                               content: this.get('remarks'), // thisはpolygonオブジェクト自体を指す
                               position: e.latLng
                           });
          // infoWindow表示
          infowindow.open(map);
        });
      }
    }
  }

  /**
   * point([緯度,軽度])の配列からLatLng型の配列を作成します
   */
  function createPathArray(points) {
    var pathArray = new Array();
    for (var i = 0; i < points.length; i++) {
      var aPoint = points[i];
      pathArray[i] = new google.maps.LatLng(aPoint[0], aPoint[1]);
    }
    return pathArray;
  }
  //]]>
</script>
<% end %>

